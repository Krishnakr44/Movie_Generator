/**
 * PDF export. Book-style layout: serif font, title page, chapter separation, readable margins.
 * Uses pdfkit (server-side only).
 */
import PDFDocument from "pdfkit";
import type { ExportResult, ExportStoryPayload } from "./types";

// Collect PDFKit stream into a Buffer (no temp files)
function streamToBuffer(stream: NodeJS.ReadableStream): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    stream.on("data", (chunk: Buffer) => chunks.push(chunk));
    stream.on("end", () => resolve(Buffer.concat(chunks)));
    stream.on("error", reject);
  });
}

export async function exportToPdf(payload: ExportStoryPayload): Promise<ExportResult> {
  const doc = new PDFDocument({
    size: "A5",
    margins: { top: 72, bottom: 72, left: 54, right: 54 },
    bufferPages: true,
  });

  // Serif font (book-like). PDFKit standard fonts: Times-Roman, Times-Bold, Times-Italic
  const font = "Times-Roman";
  const fontBold = "Times-Bold";
  const normalSize = 11;
  const titleSize = 22;
  const chapterSize = 14;

  // —— Title page ——
  doc.font(fontBold).fontSize(titleSize).text(payload.title, { align: "center" });
  doc.moveDown(0.5);
  if (payload.coverSubtitle) {
    doc.font("Times-Italic").fontSize(normalSize).text(payload.coverSubtitle, { align: "center" });
    doc.moveDown(0.5);
  }
  doc.font(font).fontSize(normalSize).text(payload.genre.replace(/_/g, " "), { align: "center" });
  doc.text(payload.author ?? "Generated by AI", { align: "center" });
  doc.moveDown(2);
  if (payload.premise) {
    doc.fontSize(10).text(payload.premise, { align: "center", width: doc.page.width - doc.page.margins.left - doc.page.margins.right });
    doc.moveDown(1);
  }
  doc.addPage();

  // —— Chapters ——
  for (const ch of payload.chapters) {
    doc.font(fontBold).fontSize(chapterSize).text(ch.title, { align: "left" });
    doc.moveDown(0.75);
    doc.font(font).fontSize(normalSize);

    const paragraphs = ch.content
      .split(/\n+/)
      .map((p) => p.trim())
      .filter(Boolean);
    for (const p of paragraphs) {
      doc.text(p, { align: "justify", lineGap: 4 });
      doc.moveDown(0.4);
    }
    doc.moveDown(0.8);
  }

  doc.end();
  const buffer = await streamToBuffer(doc);
  const safeTitle = sanitizeFilename(payload.title);

  return {
    buffer,
    mimeType: "application/pdf",
    fileExtension: "pdf",
    suggestedFilename: `${safeTitle}.pdf`,
  };
}

function sanitizeFilename(title: string): string {
  return title
    .replace(/[<>:"/\\|?*\x00-\x1f]/g, "")
    .replace(/\s+/g, " ")
    .trim()
    .slice(0, 100) || "story";
}
